import { LifeEvent } from "@/types/calendar";

export const exportEventsToCSV = (events: LifeEvent[]): string => {
  const headers = ["id", "calendarId", "title", "startDate", "endDate", "description", "icon", "isRecurring", "recurrenceType"];
  
  const rows = events.map(event => {
    return [
      event.id,
      event.calendarId,
      `"${(event.title || "").replace(/"/g, '""')}"`,
      event.startDate ? event.startDate.toISOString() : "",
      event.endDate ? event.endDate.toISOString() : "",
      `"${(event.description || "").replace(/"/g, '""')}"`,
      event.icon || "",
      event.isRecurring ? "true" : "false",
      event.recurrenceType || ""
    ].join(",");
  });

  return [headers.join(","), ...rows].join("\n");
};

export const parseCSVToEvents = (csvContent: string): Partial<LifeEvent>[] => {
  const lines = csvContent.split("\n");
  if (lines.length < 2) return [];

  const headers = lines[0].split(",").map(h => h.trim());
  const events: Partial<LifeEvent>[] = [];

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    const values: string[] = [];
    let current = '';
    let inQuotes = false;
    
    for (let j = 0; j < line.length; j++) {
      const char = line[j];
      if (char === '"') {
        if (j + 1 < line.length && line[j + 1] === '"') {
            current += '"';
            j++; // Skip next quote
        } else {
            inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        values.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    values.push(current);

    const event: any = {};
    
    // Map values to headers
    // We need to be careful if the CSV row has fewer columns than headers, or more
    // But assuming generated by us or well-formed
    
    headers.forEach((header, index) => {
      if (index >= values.length) return;
      let value = values[index].trim();
      
      // Remove surrounding quotes if they exist (though my parser above handles the content, it doesn't strip the outer quotes if I accumulated them? 
      // Wait, my parser logic above:
      // If I encounter a quote, I toggle inQuotes. I don't add the quote to `current` unless it's an escaped quote?
      // Actually, standard CSV: "field" -> field. "field""with""quote" -> field"with"quote.
      // My logic above:
      // char === '"':
      //   if next is '"': add '"', skip next.
      //   else: toggle inQuotes.
      // This logic effectively STRIPS the enclosing quotes and unescapes double quotes.
      // So `value` is already clean.
      
      if (!value) return;

      if (header === "startDate" || header === "endDate") {
        event[header] = new Date(value);
      } else if (header === "isRecurring") {
        event[header] = value === "true";
      } else {
        event[header] = value;
      }
    });
    
    // Basic validation
    if (event.title && event.startDate) {
        // Ensure ID exists, or generate one? 
        // If importing, we might want to keep ID or generate new one.
        // Let's assume we keep ID if present, or generate if missing.
        if (!event.id) event.id = crypto.randomUUID();
        events.push(event);
    }
  }

  return events;
};
